import type { ConversationItem, ThreadSummary } from "../../../types";

const MAX_THREAD_NAME_LENGTH = 38;

function formatThreadName(text: string) {
  const trimmed = text.trim();
  if (!trimmed) {
    return null;
  }
  return trimmed.length > MAX_THREAD_NAME_LENGTH
    ? `${trimmed.slice(0, MAX_THREAD_NAME_LENGTH)}â€¦`
    : trimmed;
}

export function looksAutoGeneratedThreadName(name: string) {
  return name === "New Agent" || name.startsWith("Agent ") || /^[a-f0-9]{4,8}$/i.test(name);
}

export function extractRenameText(text: string) {
  if (!text) {
    return "";
  }
  const withoutImages = text.replace(/\[image(?: x\d+)?\]/gi, " ");
  const withoutSkills = withoutImages.replace(/(^|\s)\$[A-Za-z0-9_-]+(?=\s|$)/g, " ");
  return withoutSkills.replace(/\s+/g, " ").trim();
}

function getAssistantTextForRename(
  items: ConversationItem[],
  itemId?: string,
): string {
  if (itemId) {
    const match = items.find(
      (item) =>
        item.kind === "message"
        && item.role === "assistant"
        && item.id === itemId,
    );
    if (match && match.kind === "message") {
      return match.text;
    }
  }
  for (let index = items.length - 1; index >= 0; index -= 1) {
    const item = items[index];
    if (item.kind === "message" && item.role === "assistant") {
      return item.text;
    }
  }
  return "";
}

export function maybeRenameThreadFromAgent({
  workspaceId,
  threadId,
  items,
  itemId,
  hasCustomName,
  threadsByWorkspace,
}: {
  workspaceId: string;
  threadId: string;
  items: ConversationItem[];
  itemId?: string;
  hasCustomName: boolean;
  threadsByWorkspace: Record<string, ThreadSummary[]>;
}) {
  const threads = threadsByWorkspace[workspaceId] ?? [];
  if (!threads.length) {
    return threadsByWorkspace;
  }
  const hasUserMessage = items.some(
    (item) => item.kind === "message" && item.role === "user",
  );
  if (hasUserMessage) {
    return threadsByWorkspace;
  }
  if (hasCustomName) {
    return threadsByWorkspace;
  }
  const nextName = formatThreadName(getAssistantTextForRename(items, itemId));
  if (!nextName) {
    return threadsByWorkspace;
  }
  let didChange = false;
  const nextThreads = threads.map((thread) => {
    if (
      thread.id !== threadId
      || thread.name === nextName
      || !looksAutoGeneratedThreadName(thread.name)
    ) {
      return thread;
    }
    didChange = true;
    return { ...thread, name: nextName };
  });
  return didChange
    ? { ...threadsByWorkspace, [workspaceId]: nextThreads }
    : threadsByWorkspace;
}

export function mergeStreamingText(existing: string, delta: string) {
  if (!delta) {
    return existing;
  }
  if (!existing) {
    return delta;
  }
  if (delta === existing) {
    return existing;
  }
  if (delta.startsWith(existing)) {
    return delta;
  }
  if (existing.startsWith(delta)) {
    return existing;
  }
  const maxOverlap = Math.min(existing.length, delta.length);
  for (let length = maxOverlap; length > 0; length -= 1) {
    if (existing.endsWith(delta.slice(0, length))) {
      return `${existing}${delta.slice(length)}`;
    }
  }
  return `${existing}${delta}`;
}

export function addSummaryBoundary(existing: string) {
  if (!existing) {
    return existing;
  }
  if (existing.endsWith("\n\n")) {
    return existing;
  }
  if (existing.endsWith("\n")) {
    return `${existing}\n`;
  }
  return `${existing}\n\n`;
}
