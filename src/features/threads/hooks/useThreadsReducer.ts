import type {
  AccountSnapshot,
  ApprovalRequest,
  ConversationItem,
  ProtocolItemStatus,
  ProtocolMessagePhase,
  ProtocolTurnStatus,
  RateLimitSnapshot,
  RequestUserInputRequest,
  ThreadRetryState,
  ThreadWaitReason,
  ThreadPhase,
  ThreadListSortKey,
  ThreadSummary,
  ThreadTokenUsage,
  TurnPlan,
} from "../../../types";
import {
  normalizeItem,
  prepareThreadItems,
  prepareThreadItemsIncremental,
  upsertItem,
} from "../../../utils/threadItems";
import { isTurnTerminalStatus } from "../../../utils/protocolStatus";

const MAX_THREAD_NAME_LENGTH = 38;

function formatThreadName(text: string) {
  const trimmed = text.trim();
  if (!trimmed) {
    return null;
  }
  return trimmed.length > MAX_THREAD_NAME_LENGTH
    ? `${trimmed.slice(0, MAX_THREAD_NAME_LENGTH)}…`
    : trimmed;
}

function looksAutoGeneratedThreadName(name: string) {
  return name === "New Agent" || name.startsWith("Agent ") || /^[a-f0-9]{4,8}$/i.test(name);
}

function extractRenameText(text: string) {
  if (!text) {
    return "";
  }
  const withoutImages = text.replace(/\[image(?: x\d+)?\]/gi, " ");
  const withoutSkills = withoutImages.replace(/(^|\s)\$[A-Za-z0-9_-]+(?=\s|$)/g, " ");
  return withoutSkills.replace(/\s+/g, " ").trim();
}

function getAssistantTextForRename(
  items: ConversationItem[],
  itemId?: string,
): string {
  if (itemId) {
    const match = items.find(
      (item) =>
        item.kind === "message" &&
        item.role === "assistant" &&
        item.id === itemId,
    );
    if (match && match.kind === "message") {
      return match.text;
    }
  }
  for (let index = items.length - 1; index >= 0; index -= 1) {
    const item = items[index];
    if (item.kind === "message" && item.role === "assistant") {
      return item.text;
    }
  }
  return "";
}

function maybeRenameThreadFromAgent({
  workspaceId,
  threadId,
  items,
  itemId,
  hasCustomName,
  threadsByWorkspace,
}: {
  workspaceId: string;
  threadId: string;
  items: ConversationItem[];
  itemId?: string;
  hasCustomName: boolean;
  threadsByWorkspace: Record<string, ThreadSummary[]>;
}) {
  const threads = threadsByWorkspace[workspaceId] ?? [];
  if (!threads.length) {
    return threadsByWorkspace;
  }
  const hasUserMessage = items.some(
    (item) => item.kind === "message" && item.role === "user",
  );
  if (hasUserMessage) {
    return threadsByWorkspace;
  }
  if (hasCustomName) {
    return threadsByWorkspace;
  }
  const nextName = formatThreadName(getAssistantTextForRename(items, itemId));
  if (!nextName) {
    return threadsByWorkspace;
  }
  let didChange = false;
  const nextThreads = threads.map((thread) => {
    if (
      thread.id !== threadId ||
      thread.name === nextName ||
      !looksAutoGeneratedThreadName(thread.name)
    ) {
      return thread;
    }
    didChange = true;
    return { ...thread, name: nextName };
  });
  return didChange
    ? { ...threadsByWorkspace, [workspaceId]: nextThreads }
    : threadsByWorkspace;
}

type ThreadActivityStatus = {
  isProcessing: boolean;
  hasUnread: boolean;
  isReviewing: boolean;
  // UI aggregate phase used by existing components.
  phase: ThreadPhase;
  processingStartedAt: number | null;
  lastDurationMs: number | null;
  lastActivityAt?: number | null;
  lastErrorAt?: number | null;
  lastErrorMessage?: string | null;
  // Protocol-authoritative state (do not infer from UI phase).
  turnStatus?: ProtocolTurnStatus | null;
  activeItemStatuses?: Record<string, ProtocolItemStatus>;
  messagePhase?: ProtocolMessagePhase;
  waitReason?: ThreadWaitReason;
  retryState?: ThreadRetryState;
  lastMcpProgressMessage?: string | null;
};

type ThreadTurnRuntimeMeta = {
  threadId: string;
  turnId: string;
  model: string | null;
  contextWindow: number | null;
};

export type ThreadState = {
  activeThreadIdByWorkspace: Record<string, string | null>;
  itemsByThread: Record<string, ConversationItem[]>;
  threadsByWorkspace: Record<string, ThreadSummary[]>;
  hiddenThreadIdsByWorkspace: Record<string, Record<string, true>>;
  threadParentById: Record<string, string>;
  threadStatusById: Record<string, ThreadActivityStatus>;
  threadResumeLoadingById: Record<string, boolean>;
  threadListLoadingByWorkspace: Record<string, boolean>;
  threadListPagingByWorkspace: Record<string, boolean>;
  threadListCursorByWorkspace: Record<string, string | null>;
  threadSortKeyByWorkspace: Record<string, ThreadListSortKey>;
  activeTurnIdByThread: Record<string, string | null>;
  turnDiffByThread: Record<string, string>;
  approvals: ApprovalRequest[];
  userInputRequests: RequestUserInputRequest[];
  tokenUsageByThread: Record<string, ThreadTokenUsage>;
  turnMetaByThread: Record<string, ThreadTurnRuntimeMeta | null>;
  turnMetaByTurnId: Record<string, ThreadTurnRuntimeMeta>;
  rateLimitsByWorkspace: Record<string, RateLimitSnapshot | null>;
  accountByWorkspace: Record<string, AccountSnapshot | null>;
  planByThread: Record<string, TurnPlan | null>;
  lastAgentMessageByThread: Record<string, { text: string; timestamp: number }>;
};

export type ThreadAction =
  | { type: "setActiveThreadId"; workspaceId: string; threadId: string | null }
  | { type: "ensureThread"; workspaceId: string; threadId: string }
  | { type: "hideThread"; workspaceId: string; threadId: string }
  | { type: "removeThread"; workspaceId: string; threadId: string }
  | { type: "setThreadParent"; threadId: string; parentId: string }
  | {
      type: "markProcessing";
      threadId: string;
      isProcessing: boolean;
      timestamp: number;
    }
  | {
      type: "touchThreadActivity";
      threadId: string;
      timestamp: number;
    }
  | {
      type: "setThreadTurnStatus";
      threadId: string;
      turnStatus: ProtocolTurnStatus | null;
    }
  | {
      type: "setThreadMessagePhase";
      threadId: string;
      messagePhase: ProtocolMessagePhase;
    }
  | {
      type: "setThreadWaitReason";
      threadId: string;
      waitReason: ThreadWaitReason;
    }
  | {
      type: "setThreadRetryState";
      threadId: string;
      retryState: ThreadRetryState;
    }
  | {
      type: "setActiveItemStatus";
      threadId: string;
      itemId: string;
      status: ProtocolItemStatus;
    }
  | {
      type: "clearActiveItemStatus";
      threadId: string;
      itemId: string;
    }
  | {
      type: "setMcpProgressMessage";
      threadId: string;
      message: string | null;
    }
  | {
      type: "setThreadPhase";
      threadId: string;
      phase: ThreadPhase;
    }
  | { type: "markReviewing"; threadId: string; isReviewing: boolean }
  | { type: "markUnread"; threadId: string; hasUnread: boolean }
  | {
      type: "markThreadError";
      threadId: string;
      timestamp: number;
      message: string;
    }
  | { type: "addAssistantMessage"; threadId: string; text: string }
  | { type: "setThreadName"; workspaceId: string; threadId: string; name: string }
  | {
      type: "setThreadTimestamp";
      workspaceId: string;
      threadId: string;
      timestamp: number;
    }
  | {
      type: "appendAgentDelta";
      workspaceId: string;
      threadId: string;
      itemId: string;
      delta: string;
      hasCustomName: boolean;
      turnId?: string | null;
    }
  | {
      type: "completeAgentMessage";
      workspaceId: string;
      threadId: string;
      itemId: string;
      text: string;
      hasCustomName: boolean;
      turnId?: string | null;
    }
  | {
      type: "upsertItem";
      workspaceId: string;
      threadId: string;
      item: ConversationItem;
      hasCustomName?: boolean;
    }
  | { type: "setThreadItems"; threadId: string; items: ConversationItem[] }
  | {
      type: "appendReasoningSummary";
      threadId: string;
      itemId: string;
      delta: string;
    }
  | {
      type: "appendReasoningSummaryBoundary";
      threadId: string;
      itemId: string;
    }
  | { type: "appendReasoningContent"; threadId: string; itemId: string; delta: string }
  | { type: "appendPlanDelta"; threadId: string; itemId: string; delta: string }
  | { type: "appendToolOutput"; threadId: string; itemId: string; delta: string }
  | {
      type: "setThreads";
      workspaceId: string;
      threads: ThreadSummary[];
      sortKey: ThreadListSortKey;
    }
  | {
      type: "setThreadListLoading";
      workspaceId: string;
      isLoading: boolean;
    }
  | {
      type: "setThreadResumeLoading";
      threadId: string;
      isLoading: boolean;
    }
  | {
      type: "setThreadListPaging";
      workspaceId: string;
      isLoading: boolean;
    }
  | {
      type: "setThreadListCursor";
      workspaceId: string;
      cursor: string | null;
    }
  | { type: "addApproval"; approval: ApprovalRequest }
  | { type: "removeApproval"; requestId: number | string; workspaceId: string }
  | { type: "addUserInputRequest"; request: RequestUserInputRequest }
  | {
      type: "removeUserInputRequest";
      requestId: number | string;
      workspaceId: string;
    }
  | { type: "setThreadTokenUsage"; threadId: string; tokenUsage: ThreadTokenUsage }
  | {
      type: "setThreadTurnMeta";
      threadId: string;
      turnId: string;
      model: string | null;
    }
  | {
      type: "setThreadTurnContextWindow";
      threadId: string;
      turnId: string;
      contextWindow: number | null;
    }
  | {
      type: "setRateLimits";
      workspaceId: string;
      rateLimits: RateLimitSnapshot | null;
    }
  | {
      type: "setAccountInfo";
      workspaceId: string;
      account: AccountSnapshot | null;
    }
  | { type: "setActiveTurnId"; threadId: string; turnId: string | null }
  | { type: "setThreadTurnDiff"; threadId: string; diff: string }
  | { type: "setThreadPlan"; threadId: string; plan: TurnPlan | null }
  | { type: "clearThreadPlan"; threadId: string }
  | {
      type: "setLastAgentMessage";
      threadId: string;
      text: string;
      timestamp: number;
    }
  | {
      type: "setLastAgentMessagesBulk";
      updates: Array<{
        threadId: string;
        text: string;
        timestamp: number;
      }>;
    };

const emptyItems: Record<string, ConversationItem[]> = {};
const DEFAULT_THREAD_PHASE: ThreadPhase = "completed";

export const initialState: ThreadState = {
  activeThreadIdByWorkspace: {},
  itemsByThread: emptyItems,
  threadsByWorkspace: {},
  hiddenThreadIdsByWorkspace: {},
  threadParentById: {},
  threadStatusById: {},
  threadResumeLoadingById: {},
  threadListLoadingByWorkspace: {},
  threadListPagingByWorkspace: {},
  threadListCursorByWorkspace: {},
  threadSortKeyByWorkspace: {},
  activeTurnIdByThread: {},
  turnDiffByThread: {},
  approvals: [],
  userInputRequests: [],
  tokenUsageByThread: {},
  turnMetaByThread: {},
  turnMetaByTurnId: {},
  rateLimitsByWorkspace: {},
  accountByWorkspace: {},
  planByThread: {},
  lastAgentMessageByThread: {},
};

function mergeStreamingText(existing: string, delta: string) {
  if (!delta) {
    return existing;
  }
  if (!existing) {
    return delta;
  }
  if (delta === existing) {
    return existing;
  }
  if (delta.startsWith(existing)) {
    return delta;
  }
  if (existing.startsWith(delta)) {
    return existing;
  }
  const maxOverlap = Math.min(existing.length, delta.length);
  for (let length = maxOverlap; length > 0; length -= 1) {
    if (existing.endsWith(delta.slice(0, length))) {
      return `${existing}${delta.slice(length)}`;
    }
  }
  return `${existing}${delta}`;
}

function normalizeNonEmptyString(value: string | null | undefined) {
  if (typeof value !== "string") {
    return null;
  }
  const trimmed = value.trim();
  return trimmed.length > 0 ? trimmed : null;
}

function normalizeContextWindow(value: number | null | undefined) {
  if (typeof value !== "number" || !Number.isFinite(value) || value <= 0) {
    return null;
  }
  return value;
}

function resolveTurnMetaForMessage(
  state: ThreadState,
  threadId: string,
  turnId?: string | null,
): ThreadTurnRuntimeMeta | null {
  const normalizedTurnId = normalizeNonEmptyString(turnId);
  if (normalizedTurnId) {
    const byTurn = state.turnMetaByTurnId[normalizedTurnId] ?? null;
    if (byTurn && byTurn.threadId === threadId) {
      return byTurn;
    }
  }
  const byThread = state.turnMetaByThread[threadId] ?? null;
  if (!byThread) {
    return null;
  }
  if (normalizedTurnId && byThread.turnId !== normalizedTurnId) {
    return null;
  }
  return byThread;
}

function applyAssistantRuntimeMeta(
  item: Extract<ConversationItem, { kind: "message" }>,
  meta: ThreadTurnRuntimeMeta | null,
  turnId?: string | null,
) {
  if (item.role !== "assistant") {
    return item;
  }
  const nextTurnId = normalizeNonEmptyString(turnId) ?? meta?.turnId ?? item.turnId ?? null;
  const nextModel = normalizeNonEmptyString(meta?.model) ?? item.model ?? null;
  const nextContextWindow = normalizeContextWindow(meta?.contextWindow) ?? item.contextWindow ?? null;
  return {
    ...item,
    turnId: nextTurnId,
    model: nextModel,
    contextWindow: nextContextWindow,
  };
}

function updateAssistantContextWindowForTurn(
  list: ConversationItem[],
  turnId: string,
  contextWindow: number | null,
) {
  const normalizedContextWindow = normalizeContextWindow(contextWindow);
  let didChange = false;
  const next = [...list];
  let hasExactTurnMatch = false;

  for (let index = 0; index < next.length; index += 1) {
    const item = next[index];
    if (item.kind !== "message" || item.role !== "assistant") {
      continue;
    }
    if (item.turnId !== turnId) {
      continue;
    }
    hasExactTurnMatch = true;
    if (item.contextWindow === normalizedContextWindow) {
      continue;
    }
    next[index] = {
      ...item,
      contextWindow: normalizedContextWindow,
    };
    didChange = true;
  }

  if (hasExactTurnMatch) {
    return didChange ? next : list;
  }

  for (let index = next.length - 1; index >= 0; index -= 1) {
    const item = next[index];
    if (item.kind !== "message" || item.role !== "assistant") {
      continue;
    }
    if (item.turnId && item.turnId !== turnId) {
      break;
    }
    if (item.contextWindow === normalizedContextWindow && item.turnId === turnId) {
      return list;
    }
    next[index] = {
      ...item,
      turnId,
      contextWindow: normalizedContextWindow,
    };
    return next;
  }

  return list;
}

function updateAssistantModelForTurn(
  list: ConversationItem[],
  turnId: string,
  model: string | null,
) {
  const normalizedModel = normalizeNonEmptyString(model);
  let didChange = false;
  const next = [...list];
  let hasExactTurnMatch = false;

  for (let index = 0; index < next.length; index += 1) {
    const item = next[index];
    if (item.kind !== "message" || item.role !== "assistant") {
      continue;
    }
    if (item.turnId !== turnId) {
      continue;
    }
    hasExactTurnMatch = true;
    if (item.model === normalizedModel) {
      continue;
    }
    next[index] = {
      ...item,
      model: normalizedModel,
    };
    didChange = true;
  }

  if (hasExactTurnMatch) {
    return didChange ? next : list;
  }

  for (let index = next.length - 1; index >= 0; index -= 1) {
    const item = next[index];
    if (item.kind !== "message" || item.role !== "assistant") {
      continue;
    }
    if (item.turnId && item.turnId !== turnId) {
      break;
    }
    if (item.turnId === turnId && item.model === normalizedModel) {
      return list;
    }
    next[index] = {
      ...item,
      turnId,
      model: normalizedModel,
    };
    return next;
  }

  return list;
}

function addSummaryBoundary(existing: string) {
  if (!existing) {
    return existing;
  }
  if (existing.endsWith("\n\n")) {
    return existing;
  }
  if (existing.endsWith("\n")) {
    return `${existing}\n`;
  }
  return `${existing}\n\n`;
}

function dropLatestLocalReviewStart(list: ConversationItem[]) {
  for (let index = list.length - 1; index >= 0; index -= 1) {
    const item = list[index];
    if (
      item.kind === "review" &&
      item.state === "started" &&
      item.id.startsWith("review-start-")
    ) {
      return [...list.slice(0, index), ...list.slice(index + 1)];
    }
  }
  return list;
}

function findMatchingReview(
  list: ConversationItem[],
  target: Extract<ConversationItem, { kind: "review" }>,
) {
  const normalizedText = target.text.trim();
  return list.find(
    (item) =>
      item.kind === "review" &&
      item.state === target.state &&
      item.text.trim() === normalizedText,
  );
}

function ensureUniqueReviewId(list: ConversationItem[], item: ConversationItem) {
  if (item.kind !== "review") {
    return item;
  }
  if (!list.some((entry) => entry.id === item.id)) {
    return item;
  }
  const existingIds = new Set(list.map((entry) => entry.id));
  let suffix = 1;
  let candidate = `${item.id}-${suffix}`;
  while (existingIds.has(candidate)) {
    suffix += 1;
    candidate = `${item.id}-${suffix}`;
  }
  return { ...item, id: candidate };
}

function isDuplicateReviewById(
  list: ConversationItem[],
  target: Extract<ConversationItem, { kind: "review" }>,
) {
  const normalizedText = target.text.trim();
  return list.some(
    (item) =>
      item.kind === "review" &&
      item.id === target.id &&
      item.state === target.state &&
      item.text.trim() === normalizedText,
  );
}

function prefersUpdatedSort(state: ThreadState, workspaceId: string) {
  return (state.threadSortKeyByWorkspace[workspaceId] ?? "updated_at") === "updated_at";
}

function resolveApprovalThreadId(
  approval: ApprovalRequest,
): string | null {
  const threadId = approval.params?.threadId ?? approval.params?.thread_id ?? "";
  if (typeof threadId !== "string") {
    return null;
  }
  const trimmed = threadId.trim();
  return trimmed.length > 0 ? trimmed : null;
}

function resolveUserInputThreadId(
  request: RequestUserInputRequest,
): string | null {
  const threadId = request.params?.thread_id ?? "";
  if (typeof threadId !== "string") {
    return null;
  }
  const trimmed = threadId.trim();
  return trimmed.length > 0 ? trimmed : null;
}

function buildThreadStatus(
  previous: ThreadActivityStatus | undefined,
  overrides: Partial<ThreadActivityStatus>,
): ThreadActivityStatus {
  return {
    isProcessing: previous?.isProcessing ?? false,
    hasUnread: previous?.hasUnread ?? false,
    isReviewing: previous?.isReviewing ?? false,
    phase: previous?.phase ?? DEFAULT_THREAD_PHASE,
    processingStartedAt: previous?.processingStartedAt ?? null,
    lastDurationMs: previous?.lastDurationMs ?? null,
    lastActivityAt: previous?.lastActivityAt ?? null,
    lastErrorAt: previous?.lastErrorAt ?? null,
    lastErrorMessage: previous?.lastErrorMessage ?? null,
    turnStatus: previous?.turnStatus ?? null,
    activeItemStatuses: previous?.activeItemStatuses ?? {},
    messagePhase: previous?.messagePhase ?? "unknown",
    waitReason: previous?.waitReason ?? "none",
    retryState: previous?.retryState ?? "none",
    lastMcpProgressMessage: previous?.lastMcpProgressMessage ?? null,
    ...overrides,
  };
}

function isSameActiveItemStatuses(
  left: Record<string, ProtocolItemStatus> | undefined,
  right: Record<string, ProtocolItemStatus> | undefined,
) {
  const leftMap = left ?? {};
  const rightMap = right ?? {};
  const leftEntries = Object.entries(leftMap);
  const rightEntries = Object.entries(rightMap);
  if (leftEntries.length !== rightEntries.length) {
    return false;
  }
  return leftEntries.every(([itemId, status]) => rightMap[itemId] === status);
}

function isSameThreadStatus(
  left: ThreadActivityStatus | undefined,
  right: ThreadActivityStatus,
) {
  return Boolean(
    left &&
      left.isProcessing === right.isProcessing &&
      left.hasUnread === right.hasUnread &&
      left.isReviewing === right.isReviewing &&
      left.phase === right.phase &&
      left.processingStartedAt === right.processingStartedAt &&
      left.lastDurationMs === right.lastDurationMs &&
      left.lastActivityAt === right.lastActivityAt &&
      left.lastErrorAt === right.lastErrorAt &&
      left.lastErrorMessage === right.lastErrorMessage &&
      left.turnStatus === right.turnStatus &&
      left.messagePhase === right.messagePhase &&
      left.waitReason === right.waitReason &&
      left.retryState === right.retryState &&
      left.lastMcpProgressMessage === right.lastMcpProgressMessage &&
      isSameActiveItemStatuses(left.activeItemStatuses, right.activeItemStatuses),
  );
}

export function threadReducer(state: ThreadState, action: ThreadAction): ThreadState {
  switch (action.type) {
    case "setActiveThreadId":
      return {
        ...state,
        activeThreadIdByWorkspace: {
          ...state.activeThreadIdByWorkspace,
          [action.workspaceId]: action.threadId,
        },
        threadStatusById: action.threadId
          ? {
              ...state.threadStatusById,
              [action.threadId]: buildThreadStatus(
                state.threadStatusById[action.threadId],
                { hasUnread: false },
              ),
            }
          : state.threadStatusById,
      };
    case "ensureThread": {
      const hidden =
        state.hiddenThreadIdsByWorkspace[action.workspaceId]?.[action.threadId] ??
        false;
      if (hidden) {
        return state;
      }
      const list = state.threadsByWorkspace[action.workspaceId] ?? [];
      if (list.some((thread) => thread.id === action.threadId)) {
        return state;
      }
      const thread: ThreadSummary = {
        id: action.threadId,
        name: "New Agent",
        updatedAt: 0,
      };
      return {
        ...state,
        threadsByWorkspace: {
          ...state.threadsByWorkspace,
          [action.workspaceId]: [thread, ...list],
        },
        threadStatusById: {
          ...state.threadStatusById,
          [action.threadId]: buildThreadStatus(undefined, {
            phase: DEFAULT_THREAD_PHASE,
          }),
        },
        activeThreadIdByWorkspace: {
          ...state.activeThreadIdByWorkspace,
          [action.workspaceId]:
            state.activeThreadIdByWorkspace[action.workspaceId] ?? action.threadId,
        },
      };
    }
    case "hideThread": {
      const hiddenForWorkspace =
        state.hiddenThreadIdsByWorkspace[action.workspaceId] ?? {};
      if (hiddenForWorkspace[action.threadId]) {
        return state;
      }

      const nextHiddenForWorkspace = {
        ...hiddenForWorkspace,
        [action.threadId]: true as const,
      };

      const list = state.threadsByWorkspace[action.workspaceId] ?? [];
      const filtered = list.filter((thread) => thread.id !== action.threadId);
      const nextActive =
        state.activeThreadIdByWorkspace[action.workspaceId] === action.threadId
          ? filtered[0]?.id ?? null
          : state.activeThreadIdByWorkspace[action.workspaceId] ?? null;

      return {
        ...state,
        hiddenThreadIdsByWorkspace: {
          ...state.hiddenThreadIdsByWorkspace,
          [action.workspaceId]: nextHiddenForWorkspace,
        },
        threadsByWorkspace: {
          ...state.threadsByWorkspace,
          [action.workspaceId]: filtered,
        },
        activeThreadIdByWorkspace: {
          ...state.activeThreadIdByWorkspace,
          [action.workspaceId]: nextActive,
        },
      };
    }
    case "removeThread": {
      const list = state.threadsByWorkspace[action.workspaceId] ?? [];
      const filtered = list.filter((thread) => thread.id !== action.threadId);
      const nextActive =
        state.activeThreadIdByWorkspace[action.workspaceId] === action.threadId
          ? filtered[0]?.id ?? null
          : state.activeThreadIdByWorkspace[action.workspaceId] ?? null;
      const { [action.threadId]: _, ...restItems } = state.itemsByThread;
      const { [action.threadId]: __, ...restStatus } = state.threadStatusById;
      const { [action.threadId]: ___, ...restTurns } = state.activeTurnIdByThread;
      const { [action.threadId]: ____, ...restDiffs } = state.turnDiffByThread;
      const { [action.threadId]: _____, ...restPlans } = state.planByThread;
      const { [action.threadId]: ______, ...restParents } = state.threadParentById;
      const restParentsWithoutRemovedParent = Object.fromEntries(
        Object.entries(restParents).filter(([, parentId]) => parentId !== action.threadId),
      );
      const { [action.threadId]: _______, ...restTurnMetaByThread } = state.turnMetaByThread;
      const restTurnMetaByTurnId = Object.fromEntries(
        Object.entries(state.turnMetaByTurnId).filter(
          ([, meta]) => meta.threadId !== action.threadId,
        ),
      );
      return {
        ...state,
        threadsByWorkspace: {
          ...state.threadsByWorkspace,
          [action.workspaceId]: filtered,
        },
        itemsByThread: restItems,
        threadStatusById: restStatus,
        activeTurnIdByThread: restTurns,
        turnDiffByThread: restDiffs,
        planByThread: restPlans,
        threadParentById: restParentsWithoutRemovedParent,
        turnMetaByThread: restTurnMetaByThread,
        turnMetaByTurnId: restTurnMetaByTurnId,
        activeThreadIdByWorkspace: {
          ...state.activeThreadIdByWorkspace,
          [action.workspaceId]: nextActive,
        },
      };
    }
    case "setThreadParent": {
      if (!action.parentId || action.parentId === action.threadId) {
        return state;
      }
      if (state.threadParentById[action.threadId] === action.parentId) {
        return state;
      }
      return {
        ...state,
        threadParentById: {
          ...state.threadParentById,
          [action.threadId]: action.parentId,
        },
      };
    }
    case "markProcessing": {
      const previous = state.threadStatusById[action.threadId];
      const wasProcessing = previous?.isProcessing ?? false;
      const startedAt = previous?.processingStartedAt ?? null;
      const lastDurationMs = previous?.lastDurationMs ?? null;
      if (action.isProcessing) {
        const nextStartedAt =
          wasProcessing && startedAt ? startedAt : action.timestamp;
        const nextStatus = buildThreadStatus(previous, {
          isProcessing: true,
          phase: wasProcessing ? previous?.phase ?? "starting" : "starting",
          processingStartedAt: nextStartedAt,
          lastDurationMs,
          lastActivityAt: wasProcessing
            ? previous?.lastActivityAt ?? action.timestamp
            : action.timestamp,
          lastErrorAt: null,
          lastErrorMessage: null,
          retryState: previous?.waitReason === "retry" ? "retrying" : previous?.retryState,
        });
        if (isSameThreadStatus(previous, nextStatus)) {
          return state;
        }
        return {
          ...state,
          threadStatusById: {
            ...state.threadStatusById,
            [action.threadId]: nextStatus,
          },
        };
      }
      const nextDuration =
        wasProcessing && startedAt
          ? Math.max(0, action.timestamp - startedAt)
          : lastDurationMs ?? null;
      const preservedPhase = previous?.phase;
      const nextPhase =
        preservedPhase === "failed" ||
        preservedPhase === "interrupted" ||
        preservedPhase === "stale_recovered"
          ? preservedPhase
          : "completed";
      const nextStatus = buildThreadStatus(previous, {
        isProcessing: false,
        phase: nextPhase,
        processingStartedAt: null,
        lastDurationMs: nextDuration,
        activeItemStatuses: {},
        waitReason: previous?.waitReason === "tool_wait" ? "none" : previous?.waitReason,
        retryState: previous?.waitReason === "retry" ? "none" : previous?.retryState,
        lastMcpProgressMessage: null,
      });
      if (isSameThreadStatus(previous, nextStatus)) {
        return state;
      }
      return {
        ...state,
        threadStatusById: {
          ...state.threadStatusById,
          [action.threadId]: nextStatus,
        },
      };
    }
    case "touchThreadActivity": {
      const previous = state.threadStatusById[action.threadId];
      const previousActivityAt = previous?.lastActivityAt ?? null;
      if (
        typeof previousActivityAt === "number"
        && Number.isFinite(previousActivityAt)
        && previousActivityAt >= action.timestamp
      ) {
        return state;
      }
      const nextStatus = buildThreadStatus(previous, {
        lastActivityAt: action.timestamp,
      });
      if (isSameThreadStatus(previous, nextStatus)) {
        return state;
      }
      return {
        ...state,
        threadStatusById: {
          ...state.threadStatusById,
          [action.threadId]: nextStatus,
        },
      };
    }
    case "setThreadTurnStatus": {
      const previous = state.threadStatusById[action.threadId];
      const nextStatus = buildThreadStatus(previous, {
        turnStatus: action.turnStatus,
        waitReason: isTurnTerminalStatus(action.turnStatus) ? "none" : previous?.waitReason,
        retryState: isTurnTerminalStatus(action.turnStatus) ? "none" : previous?.retryState,
        activeItemStatuses: isTurnTerminalStatus(action.turnStatus)
          ? {}
          : previous?.activeItemStatuses,
        lastMcpProgressMessage: isTurnTerminalStatus(action.turnStatus)
          ? null
          : previous?.lastMcpProgressMessage,
      });
      if (isSameThreadStatus(previous, nextStatus)) {
        return state;
      }
      return {
        ...state,
        threadStatusById: {
          ...state.threadStatusById,
          [action.threadId]: nextStatus,
        },
      };
    }
    case "setThreadMessagePhase": {
      const previous = state.threadStatusById[action.threadId];
      const nextStatus = buildThreadStatus(previous, {
        messagePhase: action.messagePhase,
      });
      if (isSameThreadStatus(previous, nextStatus)) {
        return state;
      }
      return {
        ...state,
        threadStatusById: {
          ...state.threadStatusById,
          [action.threadId]: nextStatus,
        },
      };
    }
    case "setThreadWaitReason": {
      const previous = state.threadStatusById[action.threadId];
      const nextStatus = buildThreadStatus(previous, {
        waitReason: action.waitReason,
      });
      if (isSameThreadStatus(previous, nextStatus)) {
        return state;
      }
      return {
        ...state,
        threadStatusById: {
          ...state.threadStatusById,
          [action.threadId]: nextStatus,
        },
      };
    }
    case "setThreadRetryState": {
      const previous = state.threadStatusById[action.threadId];
      const nextStatus = buildThreadStatus(previous, {
        retryState: action.retryState,
      });
      if (isSameThreadStatus(previous, nextStatus)) {
        return state;
      }
      return {
        ...state,
        threadStatusById: {
          ...state.threadStatusById,
          [action.threadId]: nextStatus,
        },
      };
    }
    case "setActiveItemStatus": {
      const previous = state.threadStatusById[action.threadId];
      const nextActiveItemStatuses = {
        ...(previous?.activeItemStatuses ?? {}),
        [action.itemId]: action.status,
      };
      const nextStatus = buildThreadStatus(previous, {
        activeItemStatuses: nextActiveItemStatuses,
      });
      if (isSameThreadStatus(previous, nextStatus)) {
        return state;
      }
      return {
        ...state,
        threadStatusById: {
          ...state.threadStatusById,
          [action.threadId]: nextStatus,
        },
      };
    }
    case "clearActiveItemStatus": {
      const previous = state.threadStatusById[action.threadId];
      if (!previous?.activeItemStatuses?.[action.itemId]) {
        return state;
      }
      const nextActiveItemStatuses = { ...previous.activeItemStatuses };
      delete nextActiveItemStatuses[action.itemId];
      const nextStatus = buildThreadStatus(previous, {
        activeItemStatuses: nextActiveItemStatuses,
      });
      if (isSameThreadStatus(previous, nextStatus)) {
        return state;
      }
      return {
        ...state,
        threadStatusById: {
          ...state.threadStatusById,
          [action.threadId]: nextStatus,
        },
      };
    }
    case "setMcpProgressMessage": {
      const previous = state.threadStatusById[action.threadId];
      const nextStatus = buildThreadStatus(previous, {
        lastMcpProgressMessage: action.message,
      });
      if (isSameThreadStatus(previous, nextStatus)) {
        return state;
      }
      return {
        ...state,
        threadStatusById: {
          ...state.threadStatusById,
          [action.threadId]: nextStatus,
        },
      };
    }
    case "setThreadPhase": {
      const previous = state.threadStatusById[action.threadId];
      const now = Date.now();
      const isActivePhase =
        action.phase === "starting" ||
        action.phase === "streaming" ||
        action.phase === "tool_running" ||
        action.phase === "waiting_user";
      if (isTurnTerminalStatus(previous?.turnStatus) && isActivePhase) {
        return state;
      }
      const isFinalPhase =
        action.phase === "completed" ||
        action.phase === "interrupted" ||
        action.phase === "failed" ||
        action.phase === "stale_recovered";
      let nextStatus = buildThreadStatus(previous, {
        phase: action.phase,
      });
      if (isActivePhase) {
        nextStatus = buildThreadStatus(nextStatus, {
          isProcessing: true,
          processingStartedAt: nextStatus.processingStartedAt ?? now,
          lastActivityAt: nextStatus.lastActivityAt ?? now,
          lastErrorAt: null,
          lastErrorMessage: null,
          waitReason:
            action.phase === "tool_running"
              ? nextStatus.waitReason === "none"
                ? "tool_wait"
                : nextStatus.waitReason
              : nextStatus.waitReason === "tool_wait"
                ? "none"
                : nextStatus.waitReason,
          retryState: action.phase === "tool_running" ? "none" : nextStatus.retryState,
        });
      } else if (isFinalPhase) {
        const nextDuration =
          action.phase === "completed" &&
          nextStatus.isProcessing &&
          nextStatus.processingStartedAt
            ? Math.max(0, now - nextStatus.processingStartedAt)
            : nextStatus.lastDurationMs;
        nextStatus = buildThreadStatus(nextStatus, {
          isProcessing: false,
          isReviewing: false,
          processingStartedAt: null,
          lastDurationMs: nextDuration,
          waitReason: "none",
          retryState: "none",
          activeItemStatuses: {},
          lastMcpProgressMessage: null,
        });
      }
      if (isSameThreadStatus(previous, nextStatus)) {
        return state;
      }
      return {
        ...state,
        threadStatusById: {
          ...state.threadStatusById,
          [action.threadId]: nextStatus,
        },
      };
    }
    case "setActiveTurnId":
      return {
        ...state,
        activeTurnIdByThread: {
          ...state.activeTurnIdByThread,
          [action.threadId]: action.turnId,
        },
      };
    case "markReviewing": {
      const previous = state.threadStatusById[action.threadId];
      const nextStatus = buildThreadStatus(previous, {
        isReviewing: action.isReviewing,
        phase: action.isReviewing
          ? "tool_running"
          : previous?.isProcessing
            ? previous?.phase === "tool_running"
              ? "starting"
              : previous?.phase ?? "starting"
            : previous?.phase ?? DEFAULT_THREAD_PHASE,
      });
      if (isSameThreadStatus(previous, nextStatus)) {
        return state;
      }
      return {
        ...state,
        threadStatusById: {
          ...state.threadStatusById,
          [action.threadId]: nextStatus,
        },
      };
    }
    case "markUnread": {
      const previous = state.threadStatusById[action.threadId];
      const nextStatus = buildThreadStatus(previous, {
        hasUnread: action.hasUnread,
      });
      if (isSameThreadStatus(previous, nextStatus)) {
        return state;
      }
      return {
        ...state,
        threadStatusById: {
          ...state.threadStatusById,
          [action.threadId]: nextStatus,
        },
      };
    }
    case "markThreadError": {
      const previous = state.threadStatusById[action.threadId];
      const normalizedMessage = action.message.trim();
      const nextStatus = buildThreadStatus(previous, {
        isProcessing: false,
        isReviewing: false,
        phase: "failed",
        processingStartedAt: null,
        lastErrorAt: action.timestamp,
        lastErrorMessage: normalizedMessage || null,
        turnStatus: "failed",
        waitReason: "none",
        retryState: "none",
        activeItemStatuses: {},
        lastMcpProgressMessage: null,
      });
      if (isSameThreadStatus(previous, nextStatus)) {
        return state;
      }
      return {
        ...state,
        threadStatusById: {
          ...state.threadStatusById,
          [action.threadId]: nextStatus,
        },
      };
    }
    case "addAssistantMessage": {
      const list = state.itemsByThread[action.threadId] ?? [];
      const message: ConversationItem = {
        id: `${Date.now()}-assistant`,
        kind: "message",
        role: "assistant",
        text: action.text,
      };
      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: prepareThreadItems([...list, message]),
        },
      };
    }
    case "setThreadName": {
      const list = state.threadsByWorkspace[action.workspaceId] ?? [];
      const next = list.map((thread) =>
        thread.id === action.threadId ? { ...thread, name: action.name } : thread,
      );
      return {
        ...state,
        threadsByWorkspace: {
          ...state.threadsByWorkspace,
          [action.workspaceId]: next,
        },
      };
    }
    case "setThreadTimestamp": {
      const list = state.threadsByWorkspace[action.workspaceId] ?? [];
      if (!list.length) {
        return state;
      }
      let didChange = false;
      const next = list.map((thread) => {
        if (thread.id !== action.threadId) {
          return thread;
        }
        const current = thread.updatedAt ?? 0;
        if (current >= action.timestamp) {
          return thread;
        }
        didChange = true;
        return { ...thread, updatedAt: action.timestamp };
      });
      if (!didChange) {
        return state;
      }
      const sorted = prefersUpdatedSort(state, action.workspaceId)
        ? [
            ...next.filter((thread) => thread.id === action.threadId),
            ...next.filter((thread) => thread.id !== action.threadId),
          ]
        : next;
      return {
        ...state,
        threadsByWorkspace: {
          ...state.threadsByWorkspace,
          [action.workspaceId]: sorted,
        },
      };
    }
    case "appendAgentDelta": {
      const currentList = state.itemsByThread[action.threadId] ?? [];
      const runtimeMeta = resolveTurnMetaForMessage(
        state,
        action.threadId,
        action.turnId ?? null,
      );
      const index = currentList.findIndex((msg) => msg.id === action.itemId);
      let updatedItems: ConversationItem[];
      if (index >= 0 && currentList[index].kind === "message") {
        const existing = currentList[index];
        const existingMessage = applyAssistantRuntimeMeta(existing, runtimeMeta, action.turnId);
        const mergedText = mergeStreamingText(existing.text, action.delta);
        if (
          mergedText === existing.text &&
          existingMessage.model === existing.model &&
          existingMessage.contextWindow === existing.contextWindow &&
          existingMessage.turnId === existing.turnId
        ) {
          return state;
        }
        const next = [...currentList];
        next[index] = {
          ...existingMessage,
          text: mergedText,
        };
        updatedItems = prepareThreadItemsIncremental(next, index);
      } else {
        const baseMessage: Extract<ConversationItem, { kind: "message" }> = {
          id: action.itemId,
          kind: "message",
          role: "assistant",
          text: action.delta,
        };
        const next = [
          ...currentList,
          applyAssistantRuntimeMeta(baseMessage, runtimeMeta, action.turnId),
        ];
        updatedItems = prepareThreadItemsIncremental(next, next.length - 1);
      }
      const nextThreadsByWorkspace = maybeRenameThreadFromAgent({
        workspaceId: action.workspaceId,
        threadId: action.threadId,
        items: updatedItems,
        itemId: action.itemId,
        hasCustomName: action.hasCustomName,
        threadsByWorkspace: state.threadsByWorkspace,
      });
      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: updatedItems,
        },
        threadsByWorkspace: nextThreadsByWorkspace,
      };
    }
    case "completeAgentMessage": {
      const currentList = state.itemsByThread[action.threadId] ?? [];
      const runtimeMeta = resolveTurnMetaForMessage(
        state,
        action.threadId,
        action.turnId ?? null,
      );
      const index = currentList.findIndex((msg) => msg.id === action.itemId);
      let updatedItems: ConversationItem[];
      if (index >= 0 && currentList[index].kind === "message") {
        const existing = currentList[index];
        const existingMessage = applyAssistantRuntimeMeta(existing, runtimeMeta, action.turnId);
        const incomingText = action.text ?? "";
        const existingText = existing.text ?? "";
        const nextText =
          incomingText.length >= existingText.length ? incomingText : existingText;
        if (
          nextText === existing.text &&
          existingMessage.model === existing.model &&
          existingMessage.contextWindow === existing.contextWindow &&
          existingMessage.turnId === existing.turnId
        ) {
          return state;
        }
        const next = [...currentList];
        next[index] = {
          ...existingMessage,
          text: nextText,
        };
        updatedItems = prepareThreadItemsIncremental(next, index);
      } else {
        const baseMessage: Extract<ConversationItem, { kind: "message" }> = {
          id: action.itemId,
          kind: "message",
          role: "assistant",
          text: action.text,
        };
        const next = [
          ...currentList,
          applyAssistantRuntimeMeta(baseMessage, runtimeMeta, action.turnId),
        ];
        updatedItems = prepareThreadItemsIncremental(next, next.length - 1);
      }
      const nextThreadsByWorkspace = maybeRenameThreadFromAgent({
        workspaceId: action.workspaceId,
        threadId: action.threadId,
        items: updatedItems,
        itemId: action.itemId,
        hasCustomName: action.hasCustomName,
        threadsByWorkspace: state.threadsByWorkspace,
      });
      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: updatedItems,
        },
        threadsByWorkspace: nextThreadsByWorkspace,
      };
    }
    case "upsertItem": {
      let list = state.itemsByThread[action.threadId] ?? [];
      const item = normalizeItem(action.item);
      const isUserMessage = item.kind === "message" && item.role === "user";
      const hadUserMessage = isUserMessage
        ? list.some((entry) => entry.kind === "message" && entry.role === "user")
        : false;
      const renameText = isUserMessage ? extractRenameText(item.text) : "";
      if (
        item.kind === "review" &&
        item.state === "started" &&
        !item.id.startsWith("review-start-")
      ) {
        list = dropLatestLocalReviewStart(list);
      }
      if (item.kind === "review" && isDuplicateReviewById(list, item)) {
        return state;
      }
      if (item.kind === "review") {
        const existing = findMatchingReview(list, item);
        if (existing && existing.id !== item.id) {
          return state;
        }
      }
      const nextItem = ensureUniqueReviewId(list, item);
      const updatedItems = prepareThreadItems(upsertItem(list, nextItem));
      let nextThreadsByWorkspace = state.threadsByWorkspace;
      if (isUserMessage) {
        const threads = state.threadsByWorkspace[action.workspaceId] ?? [];
        const textValue = renameText;
        const updatedThreads = threads.map((thread) => {
          if (thread.id !== action.threadId) {
            return thread;
          }
          const looksAutoGenerated = looksAutoGeneratedThreadName(thread.name);
          const shouldRename =
            !hadUserMessage &&
            textValue.length > 0 &&
            looksAutoGenerated &&
            !action.hasCustomName;
          const nextName =
            shouldRename && textValue.length > 38
              ? `${textValue.slice(0, 38)}…`
              : shouldRename
                ? textValue
                : thread.name;
          return { ...thread, name: nextName };
        });
        const bumpedThreads =
          prefersUpdatedSort(state, action.workspaceId) && updatedThreads.length
            ? [
                ...updatedThreads.filter((thread) => thread.id === action.threadId),
                ...updatedThreads.filter((thread) => thread.id !== action.threadId),
              ]
            : updatedThreads;
        nextThreadsByWorkspace = {
          ...state.threadsByWorkspace,
          [action.workspaceId]: bumpedThreads,
        };
      }
      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: updatedItems,
        },
        threadsByWorkspace: nextThreadsByWorkspace,
      };
    }
    case "setThreadItems":
      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: prepareThreadItems(action.items),
        },
      };
    case "setLastAgentMessage":
      if (
        state.lastAgentMessageByThread[action.threadId]?.timestamp >= action.timestamp
      ) {
        return state;
      }
      return {
        ...state,
        lastAgentMessageByThread: {
          ...state.lastAgentMessageByThread,
          [action.threadId]: { text: action.text, timestamp: action.timestamp },
        },
      };
    case "setLastAgentMessagesBulk": {
      if (action.updates.length === 0) {
        return state;
      }
      let didChange = false;
      const nextLastAgentMessageByThread = { ...state.lastAgentMessageByThread };
      action.updates.forEach((update) => {
        if (!update.threadId || !update.text) {
          return;
        }
        const existing = nextLastAgentMessageByThread[update.threadId];
        if (existing?.timestamp >= update.timestamp) {
          return;
        }
        nextLastAgentMessageByThread[update.threadId] = {
          text: update.text,
          timestamp: update.timestamp,
        };
        didChange = true;
      });
      if (!didChange) {
        return state;
      }
      return {
        ...state,
        lastAgentMessageByThread: nextLastAgentMessageByThread,
      };
    }
    case "appendReasoningSummary": {
      const list = state.itemsByThread[action.threadId] ?? [];
      const index = list.findIndex((entry) => entry.id === action.itemId);
      const base =
        index >= 0 && list[index].kind === "reasoning"
          ? (list[index] as ConversationItem)
          : {
              id: action.itemId,
              kind: "reasoning",
              summary: "",
              content: "",
            };
      const nextSummary = mergeStreamingText(
        "summary" in base ? base.summary : "",
        action.delta,
      );
      if (nextSummary === ("summary" in base ? base.summary : "")) {
        return state;
      }
      const updated: ConversationItem = {
        ...base,
        summary: nextSummary,
      } as ConversationItem;
      const next = index >= 0 ? [...list] : [...list, updated];
      const changedIndex = index >= 0 ? index : next.length - 1;
      if (index >= 0) {
        next[index] = updated;
      }
      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: prepareThreadItemsIncremental(next, changedIndex),
        },
      };
    }
    case "appendReasoningSummaryBoundary": {
      const list = state.itemsByThread[action.threadId] ?? [];
      const index = list.findIndex((entry) => entry.id === action.itemId);
      const base =
        index >= 0 && list[index].kind === "reasoning"
          ? (list[index] as ConversationItem)
          : {
              id: action.itemId,
              kind: "reasoning",
              summary: "",
              content: "",
            };
      const nextSummary = addSummaryBoundary("summary" in base ? base.summary : "");
      if (nextSummary === ("summary" in base ? base.summary : "")) {
        return state;
      }
      const updated: ConversationItem = {
        ...base,
        summary: nextSummary,
      } as ConversationItem;
      const next = index >= 0 ? [...list] : [...list, updated];
      const changedIndex = index >= 0 ? index : next.length - 1;
      if (index >= 0) {
        next[index] = updated;
      }
      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: prepareThreadItemsIncremental(next, changedIndex),
        },
      };
    }
    case "appendReasoningContent": {
      const list = state.itemsByThread[action.threadId] ?? [];
      const index = list.findIndex((entry) => entry.id === action.itemId);
      const base =
        index >= 0 && list[index].kind === "reasoning"
          ? (list[index] as ConversationItem)
          : {
              id: action.itemId,
              kind: "reasoning",
              summary: "",
              content: "",
            };
      const nextContent = mergeStreamingText(
        "content" in base ? base.content : "",
        action.delta,
      );
      if (nextContent === ("content" in base ? base.content : "")) {
        return state;
      }
      const updated: ConversationItem = {
        ...base,
        content: nextContent,
      } as ConversationItem;
      const next = index >= 0 ? [...list] : [...list, updated];
      const changedIndex = index >= 0 ? index : next.length - 1;
      if (index >= 0) {
        next[index] = updated;
      }
      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: prepareThreadItemsIncremental(next, changedIndex),
        },
      };
    }
    case "appendPlanDelta": {
      const list = state.itemsByThread[action.threadId] ?? [];
      const index = list.findIndex((entry) => entry.id === action.itemId);
      const base =
        index >= 0 && list[index].kind === "tool"
          ? list[index]
          : {
              id: action.itemId,
              kind: "tool",
              toolType: "plan",
              title: "方案",
              detail: "",
              status: "in_progress",
              output: "",
            };
      const existingOutput =
        base.kind === "tool" ? (base.output ?? "") : "";
      const mergedOutput = mergeStreamingText(existingOutput, action.delta);
      if (mergedOutput === existingOutput && index >= 0) {
        return state;
      }
      const updated: ConversationItem = {
        ...(base as ConversationItem),
        kind: "tool",
        toolType: "plan",
        title: "方案",
        detail: "Generating plan...",
        status: "in_progress",
        output: mergedOutput,
      } as ConversationItem;
      const next = index >= 0 ? [...list] : [...list, updated];
      const changedIndex = index >= 0 ? index : next.length - 1;
      if (index >= 0) {
        next[index] = updated;
      }
      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: prepareThreadItemsIncremental(next, changedIndex),
        },
      };
    }
    case "appendToolOutput": {
      const list = state.itemsByThread[action.threadId] ?? [];
      const index = list.findIndex((entry) => entry.id === action.itemId);
      if (index < 0 || list[index].kind !== "tool") {
        return state;
      }
      const existing = list[index];
      const mergedOutput = mergeStreamingText(existing.output ?? "", action.delta);
      if (mergedOutput === (existing.output ?? "")) {
        return state;
      }
      const updated: ConversationItem = {
        ...existing,
        output: mergedOutput,
      } as ConversationItem;
      const next = [...list];
      next[index] = updated;
      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: prepareThreadItemsIncremental(next, index),
        },
      };
    }
    case "addApproval": {
      const exists = state.approvals.some(
        (item) =>
          item.request_id === action.approval.request_id &&
          item.workspace_id === action.approval.workspace_id,
      );
      if (exists) {
        return state;
      }
      const nextApprovals = [...state.approvals, action.approval];
      const threadId = resolveApprovalThreadId(action.approval);
      if (!threadId) {
        return { ...state, approvals: nextApprovals };
      }
      const previousStatus = state.threadStatusById[threadId];
      const nextStatus = buildThreadStatus(previousStatus, {
        waitReason: "approval",
      });
      return {
        ...state,
        approvals: nextApprovals,
        threadStatusById: isSameThreadStatus(previousStatus, nextStatus)
          ? state.threadStatusById
          : {
              ...state.threadStatusById,
              [threadId]: nextStatus,
            },
      };
    }
    case "removeApproval": {
      const removed = state.approvals.find(
        (item) =>
          item.request_id === action.requestId &&
          item.workspace_id === action.workspaceId,
      );
      const approvals = state.approvals.filter(
        (item) =>
          item.request_id !== action.requestId ||
          item.workspace_id !== action.workspaceId,
      );
      const threadId = removed ? resolveApprovalThreadId(removed) : null;
      if (!threadId) {
        return {
          ...state,
          approvals,
        };
      }
      const hasApprovalPending = approvals.some(
        (item) =>
          item.workspace_id === action.workspaceId &&
          resolveApprovalThreadId(item) === threadId,
      );
      const hasUserInputPending = state.userInputRequests.some(
        (item) =>
          item.workspace_id === action.workspaceId &&
          resolveUserInputThreadId(item) === threadId,
      );
      const previousStatus = state.threadStatusById[threadId];
      const nextWaitReason: ThreadWaitReason = hasApprovalPending
        ? "approval"
        : hasUserInputPending
          ? "user_input"
          : previousStatus?.waitReason === "retry"
            ? "retry"
            : "none";
      const nextStatus = buildThreadStatus(previousStatus, {
        waitReason: nextWaitReason,
      });
      return {
        ...state,
        approvals,
        threadStatusById: isSameThreadStatus(previousStatus, nextStatus)
          ? state.threadStatusById
          : {
              ...state.threadStatusById,
              [threadId]: nextStatus,
            },
      };
    }
    case "addUserInputRequest": {
      const exists = state.userInputRequests.some(
        (item) =>
          item.request_id === action.request.request_id &&
          item.workspace_id === action.request.workspace_id,
      );
      if (exists) {
        return state;
      }
      const nextUserInputRequests = [...state.userInputRequests, action.request];
      const threadId = resolveUserInputThreadId(action.request);
      if (!threadId) {
        return {
          ...state,
          userInputRequests: nextUserInputRequests,
        };
      }
      const previousStatus = state.threadStatusById[threadId];
      const nextStatus = buildThreadStatus(previousStatus, {
        waitReason: "user_input",
      });
      return {
        ...state,
        userInputRequests: nextUserInputRequests,
        threadStatusById: isSameThreadStatus(previousStatus, nextStatus)
          ? state.threadStatusById
          : {
              ...state.threadStatusById,
              [threadId]: nextStatus,
            },
      };
    }
    case "removeUserInputRequest": {
      const removed = state.userInputRequests.find(
        (item) =>
          item.request_id === action.requestId &&
          item.workspace_id === action.workspaceId,
      );
      const userInputRequests = state.userInputRequests.filter(
        (item) =>
          item.request_id !== action.requestId ||
          item.workspace_id !== action.workspaceId,
      );
      const threadId = removed ? resolveUserInputThreadId(removed) : null;
      if (!threadId) {
        return {
          ...state,
          userInputRequests,
        };
      }
      const hasApprovalPending = state.approvals.some(
        (item) =>
          item.workspace_id === action.workspaceId &&
          resolveApprovalThreadId(item) === threadId,
      );
      const hasUserInputPending = userInputRequests.some(
        (item) =>
          item.workspace_id === action.workspaceId &&
          resolveUserInputThreadId(item) === threadId,
      );
      const previousStatus = state.threadStatusById[threadId];
      const nextWaitReason: ThreadWaitReason = hasApprovalPending
        ? "approval"
        : hasUserInputPending
          ? "user_input"
          : previousStatus?.waitReason === "retry"
            ? "retry"
            : "none";
      const nextStatus = buildThreadStatus(previousStatus, {
        waitReason: nextWaitReason,
      });
      return {
        ...state,
        userInputRequests,
        threadStatusById: isSameThreadStatus(previousStatus, nextStatus)
          ? state.threadStatusById
          : {
              ...state.threadStatusById,
              [threadId]: nextStatus,
            },
      };
    }
    case "setThreads": {
      const hidden = state.hiddenThreadIdsByWorkspace[action.workspaceId] ?? {};
      const visibleThreads = action.threads.filter((thread) => !hidden[thread.id]);
      return {
        ...state,
        threadsByWorkspace: {
          ...state.threadsByWorkspace,
          [action.workspaceId]: visibleThreads,
        },
        threadSortKeyByWorkspace: {
          ...state.threadSortKeyByWorkspace,
          [action.workspaceId]: action.sortKey,
        },
      };
    }
    case "setThreadListLoading":
      return {
        ...state,
        threadListLoadingByWorkspace: {
          ...state.threadListLoadingByWorkspace,
          [action.workspaceId]: action.isLoading,
        },
      };
    case "setThreadResumeLoading":
      return {
        ...state,
        threadResumeLoadingById: {
          ...state.threadResumeLoadingById,
          [action.threadId]: action.isLoading,
        },
      };
    case "setThreadListPaging":
      return {
        ...state,
        threadListPagingByWorkspace: {
          ...state.threadListPagingByWorkspace,
          [action.workspaceId]: action.isLoading,
        },
      };
    case "setThreadListCursor":
      return {
        ...state,
        threadListCursorByWorkspace: {
          ...state.threadListCursorByWorkspace,
          [action.workspaceId]: action.cursor,
        },
      };
    case "setThreadTokenUsage":
      return {
        ...state,
        tokenUsageByThread: {
          ...state.tokenUsageByThread,
          [action.threadId]: action.tokenUsage,
        },
      };
    case "setThreadTurnMeta": {
      const normalizedTurnId = normalizeNonEmptyString(action.turnId);
      if (!normalizedTurnId) {
        return state;
      }
      const normalizedModel = normalizeNonEmptyString(action.model);
      const previousForThread = state.turnMetaByThread[action.threadId] ?? null;
      const nextForThread: ThreadTurnRuntimeMeta = {
        threadId: action.threadId,
        turnId: normalizedTurnId,
        model: normalizedModel,
        contextWindow: previousForThread?.turnId === normalizedTurnId
          ? normalizeContextWindow(previousForThread.contextWindow)
          : null,
      };
      const nextTurnMetaByTurnId = { ...state.turnMetaByTurnId };
      if (
        previousForThread &&
        previousForThread.turnId !== normalizedTurnId &&
        nextTurnMetaByTurnId[previousForThread.turnId]?.threadId === action.threadId
      ) {
        delete nextTurnMetaByTurnId[previousForThread.turnId];
      }
      nextTurnMetaByTurnId[normalizedTurnId] = nextForThread;
      const currentItems = state.itemsByThread[action.threadId] ?? [];
      const nextItems = updateAssistantModelForTurn(
        currentItems,
        normalizedTurnId,
        normalizedModel,
      );
      return {
        ...state,
        itemsByThread:
          nextItems === currentItems
            ? state.itemsByThread
            : {
                ...state.itemsByThread,
                [action.threadId]: prepareThreadItems(nextItems),
              },
        turnMetaByThread: {
          ...state.turnMetaByThread,
          [action.threadId]: nextForThread,
        },
        turnMetaByTurnId: nextTurnMetaByTurnId,
      };
    }
    case "setThreadTurnContextWindow": {
      const normalizedTurnId = normalizeNonEmptyString(action.turnId);
      if (!normalizedTurnId) {
        return state;
      }
      const previousByTurn = state.turnMetaByTurnId[normalizedTurnId] ?? null;
      const previousByThread = state.turnMetaByThread[action.threadId] ?? null;
      const contextWindow = normalizeContextWindow(action.contextWindow);
      const nextMeta: ThreadTurnRuntimeMeta = {
        threadId: action.threadId,
        turnId: normalizedTurnId,
        model: normalizeNonEmptyString(previousByTurn?.model ?? previousByThread?.model) ?? null,
        contextWindow,
      };
      const currentItems = state.itemsByThread[action.threadId] ?? [];
      const nextItems = updateAssistantContextWindowForTurn(
        currentItems,
        normalizedTurnId,
        contextWindow,
      );
      return {
        ...state,
        itemsByThread:
          nextItems === currentItems
            ? state.itemsByThread
            : {
                ...state.itemsByThread,
                [action.threadId]: prepareThreadItems(nextItems),
              },
        turnMetaByThread: {
          ...state.turnMetaByThread,
          [action.threadId]: nextMeta,
        },
        turnMetaByTurnId: {
          ...state.turnMetaByTurnId,
          [normalizedTurnId]: nextMeta,
        },
      };
    }
    case "setRateLimits":
      return {
        ...state,
        rateLimitsByWorkspace: {
          ...state.rateLimitsByWorkspace,
          [action.workspaceId]: action.rateLimits,
        },
      };
    case "setAccountInfo":
      return {
        ...state,
        accountByWorkspace: {
          ...state.accountByWorkspace,
          [action.workspaceId]: action.account,
        },
      };
    case "setThreadTurnDiff":
      return {
        ...state,
        turnDiffByThread: {
          ...state.turnDiffByThread,
          [action.threadId]: action.diff,
        },
      };
    case "setThreadPlan":
      return {
        ...state,
        planByThread: {
          ...state.planByThread,
          [action.threadId]: action.plan,
        },
      };
    case "clearThreadPlan":
      return {
        ...state,
        planByThread: {
          ...state.planByThread,
          [action.threadId]: null,
        },
      };
    default:
      return state;
  }
}
