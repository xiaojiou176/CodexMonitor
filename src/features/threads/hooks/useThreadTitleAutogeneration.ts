import { useCallback, useRef } from "react";
import type { MutableRefObject } from "react";
import type { ConversationItem, DebugEntry, ThreadSummary } from "@/types";
import { generateRunMetadata } from "@services/tauri";

const MAX_THREAD_NAME_LENGTH = 38;
const MAX_PROMPT_CHARS = 1200;

function looksAutoGeneratedThreadName(name: string) {
  return (
    name === "New Agent" ||
    name.startsWith("Agent ") ||
    /^[a-f0-9]{4,8}$/i.test(name)
  );
}

function clampThreadTitle(title: string) {
  const trimmed = title.replace(/\s+/g, " ").trim();
  if (!trimmed) {
    return null;
  }
  return trimmed.length > MAX_THREAD_NAME_LENGTH
    ? `${trimmed.slice(0, MAX_THREAD_NAME_LENGTH)}â€¦`
    : trimmed;
}

function cleanPromptText(text: string) {
  if (!text) {
    return "";
  }
  const withoutImages = text.replace(/\[image(?: x\d+)?\]/gi, " ");
  const withoutSkills = withoutImages.replace(/(^|\s)\$[A-Za-z0-9_-]+(?=\s|$)/g, " ");
  const normalized = withoutSkills.replace(/\s+/g, " ").trim();
  return normalized.length > MAX_PROMPT_CHARS
    ? normalized.slice(0, MAX_PROMPT_CHARS)
    : normalized;
}

type UseThreadTitleAutogenerationOptions = {
  enabled: boolean;
  itemsByThreadRef: MutableRefObject<Record<string, ConversationItem[]>>;
  threadsByWorkspaceRef: MutableRefObject<Record<string, ThreadSummary[]>>;
  getCustomName: (workspaceId: string, threadId: string) => string | undefined;
  renameThread: (workspaceId: string, threadId: string, title: string) => void;
  onDebug?: (entry: DebugEntry) => void;
};

export function useThreadTitleAutogeneration({
  enabled,
  itemsByThreadRef,
  threadsByWorkspaceRef,
  getCustomName,
  renameThread,
  onDebug,
}: UseThreadTitleAutogenerationOptions) {
  const inFlightRef = useRef<Record<string, true>>({});

  const onUserMessageCreated = useCallback(
    async (workspaceId: string, threadId: string, text: string) => {
      if (!enabled) {
        return;
      }
      if (!workspaceId || !threadId) {
        return;
      }
      if (getCustomName(workspaceId, threadId)) {
        return;
      }
      const key = `${workspaceId}:${threadId}`;
      if (inFlightRef.current[key]) {
        return;
      }

      const existingItems = itemsByThreadRef.current[threadId] ?? [];
      const alreadyHasUserMessage = existingItems.some(
        (item) => item.kind === "message" && item.role === "user",
      );
      if (alreadyHasUserMessage) {
        return;
      }

      const threads = threadsByWorkspaceRef.current[workspaceId] ?? [];
      const thread = threads.find((entry) => entry.id === threadId) ?? null;
      if (thread && !looksAutoGeneratedThreadName(thread.name)) {
        return;
      }

      const cleaned = cleanPromptText(text);
      if (!cleaned) {
        return;
      }

      inFlightRef.current[key] = true;
      try {
        const metadata = await generateRunMetadata(workspaceId, cleaned);
        const title = clampThreadTitle(metadata.title ?? "");
        if (!title) {
          return;
        }
        if (getCustomName(workspaceId, threadId)) {
          return;
        }
        renameThread(workspaceId, threadId, title);
      } catch (error) {
        onDebug?.({
          id: `${Date.now()}-thread-title-autogen-error`,
          timestamp: Date.now(),
          source: "error",
          label: "thread/title autogen error",
          payload: error instanceof Error ? error.message : String(error),
        });
      } finally {
        delete inFlightRef.current[key];
      }
    },
    [
      enabled,
      getCustomName,
      itemsByThreadRef,
      threadsByWorkspaceRef,
      renameThread,
      onDebug,
    ],
  );

  return { onUserMessageCreated };
}

