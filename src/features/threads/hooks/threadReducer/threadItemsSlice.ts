import type { ConversationItem } from "@/types";
import { normalizeItem, prepareThreadItems, upsertItem } from "@utils/threadItems";
import type { ThreadAction, ThreadState } from "../useThreadsReducer";
import {
  addSummaryBoundary,
  dropLatestLocalReviewStart,
  ensureUniqueReviewId,
  extractRenameText,
  findMatchingReview,
  isDuplicateReviewById,
  looksAutoGeneratedThreadName,
  maybeRenameThreadFromAgent,
  mergeStreamingText,
  prefersUpdatedSort,
} from "./common";

export function reduceThreadItems(state: ThreadState, action: ThreadAction): ThreadState {
  switch (action.type) {
    case "addAssistantMessage": {
      const list = state.itemsByThread[action.threadId] ?? [];
      const message: ConversationItem = {
        id: `${Date.now()}-assistant`,
        kind: "message",
        role: "assistant",
        text: action.text,
      };
      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: prepareThreadItems([...list, message], { maxItemsPerThread: state.maxItemsPerThread }),
        },
      };
    }
    case "appendAgentDelta": {
      const list = [...(state.itemsByThread[action.threadId] ?? [])];
      const index = list.findIndex((msg) => msg.id === action.itemId);
      if (index >= 0 && list[index].kind === "message") {
        const existing = list[index];
        list[index] = {
          ...existing,
          text: mergeStreamingText(existing.text, action.delta),
        };
      } else {
        list.push({
          id: action.itemId,
          kind: "message",
          role: "assistant",
          text: action.delta,
        });
      }
      const updatedItems = prepareThreadItems(list, { maxItemsPerThread: state.maxItemsPerThread });
      const nextThreadsByWorkspace = maybeRenameThreadFromAgent({
        workspaceId: action.workspaceId,
        threadId: action.threadId,
        items: updatedItems,
        itemId: action.itemId,
        hasCustomName: action.hasCustomName,
        threadsByWorkspace: state.threadsByWorkspace,
      });
      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: updatedItems,
        },
        threadsByWorkspace: nextThreadsByWorkspace,
      };
    }
    case "completeAgentMessage": {
      const list = [...(state.itemsByThread[action.threadId] ?? [])];
      const index = list.findIndex((msg) => msg.id === action.itemId);
      if (index >= 0 && list[index].kind === "message") {
        const existing = list[index];
        list[index] = {
          ...existing,
          text: action.text || existing.text,
        };
      } else {
        list.push({
          id: action.itemId,
          kind: "message",
          role: "assistant",
          text: action.text,
        });
      }
      const updatedItems = prepareThreadItems(list, { maxItemsPerThread: state.maxItemsPerThread });
      const nextThreadsByWorkspace = maybeRenameThreadFromAgent({
        workspaceId: action.workspaceId,
        threadId: action.threadId,
        items: updatedItems,
        itemId: action.itemId,
        hasCustomName: action.hasCustomName,
        threadsByWorkspace: state.threadsByWorkspace,
      });
      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: updatedItems,
        },
        threadsByWorkspace: nextThreadsByWorkspace,
      };
    }
    case "upsertItem": {
      let list = state.itemsByThread[action.threadId] ?? [];
      const item = normalizeItem(action.item);
      const isUserMessage = item.kind === "message" && item.role === "user";
      const hadUserMessage = isUserMessage
        ? list.some((entry) => entry.kind === "message" && entry.role === "user")
        : false;
      const renameText = isUserMessage ? extractRenameText(item.text) : "";
      if (
        item.kind === "review" &&
        item.state === "started" &&
        !item.id.startsWith("review-start-")
      ) {
        list = dropLatestLocalReviewStart(list);
      }
      if (item.kind === "review" && isDuplicateReviewById(list, item)) {
        return state;
      }
      if (item.kind === "review") {
        const existing = findMatchingReview(list, item);
        if (existing && existing.id !== item.id) {
          return state;
        }
      }
      const nextItem = ensureUniqueReviewId(list, item);
      const updatedItems = prepareThreadItems(upsertItem(list, nextItem), { maxItemsPerThread: state.maxItemsPerThread });
      let nextThreadsByWorkspace = state.threadsByWorkspace;
      if (isUserMessage) {
        const threads = state.threadsByWorkspace[action.workspaceId] ?? [];
        const textValue = renameText;
        const updatedThreads = threads.map((thread) => {
          if (thread.id !== action.threadId) {
            return thread;
          }
          const looksAutoGenerated = looksAutoGeneratedThreadName(thread.name);
          const shouldRename =
            !hadUserMessage &&
            textValue.length > 0 &&
            looksAutoGenerated &&
            !action.hasCustomName;
          const nextName =
            shouldRename && textValue.length > 38
              ? `${textValue.slice(0, 38)}â€¦`
              : shouldRename
                ? textValue
                : thread.name;
          return { ...thread, name: nextName };
        });
        const bumpedThreads =
          prefersUpdatedSort(state, action.workspaceId) && updatedThreads.length
            ? [
                ...updatedThreads.filter((thread) => thread.id === action.threadId),
                ...updatedThreads.filter((thread) => thread.id !== action.threadId),
              ]
            : updatedThreads;
        nextThreadsByWorkspace = {
          ...state.threadsByWorkspace,
          [action.workspaceId]: bumpedThreads,
        };
      }
      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: updatedItems,
        },
        threadsByWorkspace: nextThreadsByWorkspace,
      };
    }
    case "setThreadItems":
      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: prepareThreadItems(action.items, { maxItemsPerThread: state.maxItemsPerThread }),
        },
      };
    case "appendReasoningSummary": {
      const list = state.itemsByThread[action.threadId] ?? [];
      const index = list.findIndex((entry) => entry.id === action.itemId);
      const base =
        index >= 0 && list[index].kind === "reasoning"
          ? (list[index] as ConversationItem)
          : {
              id: action.itemId,
              kind: "reasoning",
              summary: "",
              content: "",
            };
      const updated: ConversationItem = {
        ...base,
        summary: mergeStreamingText(
          "summary" in base ? base.summary : "",
          action.delta,
        ),
      } as ConversationItem;
      const next = index >= 0 ? [...list] : [...list, updated];
      if (index >= 0) {
        next[index] = updated;
      }
      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: prepareThreadItems(next, { maxItemsPerThread: state.maxItemsPerThread }),
        },
      };
    }
    case "appendReasoningSummaryBoundary": {
      const list = state.itemsByThread[action.threadId] ?? [];
      const index = list.findIndex((entry) => entry.id === action.itemId);
      const base =
        index >= 0 && list[index].kind === "reasoning"
          ? (list[index] as ConversationItem)
          : {
              id: action.itemId,
              kind: "reasoning",
              summary: "",
              content: "",
            };
      const updated: ConversationItem = {
        ...base,
        summary: addSummaryBoundary("summary" in base ? base.summary : ""),
      } as ConversationItem;
      const next = index >= 0 ? [...list] : [...list, updated];
      if (index >= 0) {
        next[index] = updated;
      }
      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: prepareThreadItems(next, { maxItemsPerThread: state.maxItemsPerThread }),
        },
      };
    }
    case "appendReasoningContent": {
      const list = state.itemsByThread[action.threadId] ?? [];
      const index = list.findIndex((entry) => entry.id === action.itemId);
      const base =
        index >= 0 && list[index].kind === "reasoning"
          ? (list[index] as ConversationItem)
          : {
              id: action.itemId,
              kind: "reasoning",
              summary: "",
              content: "",
            };
      const updated: ConversationItem = {
        ...base,
        content: mergeStreamingText(
          "content" in base ? base.content : "",
          action.delta,
        ),
      } as ConversationItem;
      const next = index >= 0 ? [...list] : [...list, updated];
      if (index >= 0) {
        next[index] = updated;
      }
      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: prepareThreadItems(next, { maxItemsPerThread: state.maxItemsPerThread }),
        },
      };
    }
    case "appendPlanDelta": {
      const list = state.itemsByThread[action.threadId] ?? [];
      const index = list.findIndex((entry) => entry.id === action.itemId);
      const base =
        index >= 0 && list[index].kind === "tool"
          ? list[index]
          : {
              id: action.itemId,
              kind: "tool",
              toolType: "plan",
              title: "Plan",
              detail: "",
              status: "in_progress",
              output: "",
            };
      const existingOutput = base.kind === "tool" ? (base.output ?? "") : "";
      const updated: ConversationItem = {
        ...(base as ConversationItem),
        kind: "tool",
        toolType: "plan",
        title: "Plan",
        detail: "Generating plan...",
        status: "in_progress",
        output: mergeStreamingText(existingOutput, action.delta),
      } as ConversationItem;
      const next = index >= 0 ? [...list] : [...list, updated];
      if (index >= 0) {
        next[index] = updated;
      }
      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: prepareThreadItems(next, { maxItemsPerThread: state.maxItemsPerThread }),
        },
      };
    }
    case "appendToolOutput": {
      const list = state.itemsByThread[action.threadId] ?? [];
      const index = list.findIndex((entry) => entry.id === action.itemId);
      if (index < 0 || list[index].kind !== "tool") {
        return state;
      }
      const existing = list[index];
      const updated: ConversationItem = {
        ...existing,
        output: mergeStreamingText(existing.output ?? "", action.delta),
      } as ConversationItem;
      const next = [...list];
      next[index] = updated;
      return {
        ...state,
        itemsByThread: {
          ...state.itemsByThread,
          [action.threadId]: prepareThreadItems(next, { maxItemsPerThread: state.maxItemsPerThread }),
        },
      };
    }
    default:
      return state;
  }
}
